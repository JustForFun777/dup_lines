# Поиск дубликатов строк
Программа предназначена для поиска дубликатов строк в текстовых файлах.

При этом используется метод префикса-бора, составляется двумерный массив, представляющий из себя дерево.

# Сборка и запуск тестов

## Сборка исполняемого файла

make project

В директории build/ появится исполняемый файл

## Сборка и запуск тестов

make test

Будет произведена сборка и запуск тестов - пока простейшие тесты на проверку дупликатов и уникльных строк

# Запуск программы

## Получить help

./build/dupl -h

## Поиск дупликатов строк

./build/dupl -f build/test/test_very_simple/test.txt -d

на экран будут выводиться строки которые найдены больше чем в одном экземпляре в файле.

При этом количество дупликатов не отображается

## Поиск уникальных строк в файле

./build/dupl -f build/test/test_very_simple/test.txt -u

На экран будут выведены строки которые встречаются в одном экземпляре в файле.

# Внимание

Программа потребляет много памяти, это особенность построения дерева на основе массива.

Но процессорное время минимально.

По факту сложность поиска дубликатов (обработки файла) равна O(n) где n - количество символов в файле

Что касается поиска уникальных строк, то алгоритм потребляет еще больше памяти за счет сохранения в памяти всего файла.

# Описание алгоритма поиска дупликатов

Пример работы добавления-поиска по данному методу

Создается двумерный массив go и одномерный term

в go вводятся строки специальным образом, а в term - е находятся признаки окончания строки

Пример:

Ввод строки:

1) abc
```
        GO           term    
    a-b-c-d-e-f              
    0-1-2-3-4-5              
 0 !1!0-0-0-0-0      0       
 1  0!2!0-0-0-0      0       
 2  0-0!3!0-0-0      0       
 3  0-0-0-0-0-0      1       
 4  0-0-0-0-0-0      0       
 5  0-0-0-0-0-0      0       
 6  0-0-0-0-0-0      0       
 7  0-0-0-0-0-0      0       
 8  0-0-0-0-0-0      0       
 9  0-0-0-0-0-0      0       
 10 0-0-0-0-0-0      0       
```

2) abd
```
        GO           term    
    a-b-c-d-e-f              
    0-1-2-3-4-5              
 0 >1<0-0-0-0-0      0       
 1  0>2<0-0-0-0      0       
 2  0-0-3!4!0-0      0       
 3  0-0-0-0-0-0      1       
 4  0-0-0-0-0-0      1       
 5  0-0-0-0-0-0      0       
 6  0-0-0-0-0-0      0       
 7  0-0-0-0-0-0      0       
 8  0-0-0-0-0-0      0       
 9  0-0-0-0-0-0      0       
 10 0-0-0-0-0-0      0       
```

3) bad
```
        GO           term    
    a-b-c-d-e-f              
    0-1-2-3-4-5              
 0  1!5!0-0-0-0      0       
 1  0-2-0-0-0-0      0       
 2  0-0-3-4-0-0      0       
 3  0-0-0-0-0-0      1       
 4  0-0-0-0-0-0      1       
 5 !6!0-0-0-0-0      0       
 6  0-0-0!7!0-0      0       
 7  0-0-0-0-0-0      1       
 8  0-0-0-0-0-0      0       
 9  0-0-0-0-0-0      0       
 10 0-0-0-0-0-0      0       
```

3) bacf
```
        GO           term    
    a-b-c-d-e-f              
    0-1-2-3-4-5              
 0  1>5<0-0-0-0      0       
 1  0-2-0-0-0-0      0       
 2  0-0-3-4-0-0      0       
 3  0-0-0-0-0-0      1       
 4  0-0-0-0-0-0      1       
 5 >6<0-0-0-0-0      0       
 6  0-0!8!7-0-0      0       
 7  0-0-0-0-0-0      1       
 8  0-0-0-0-0!9!     0       
 9  0-0-0-0-0-0      1       
 10 0-0-0-0-0-0      0       
```

4) bace
```
        GO           term    
    a-b-c-d-e-f              
    0-1-2-3-4-5              
 0  1>5<0-0-0-0      0       
 1  0-2-0-0-0-0      0       
 2  0-0-3-4-0-0      0       
 3  0-0-0-0-0-0      1       
 4  0-0-0-0-0-0      1       
 5 >6<0-0-0-0-0      0       
 6  0-0>8<7-0-0      0       
 7  0-0-0-0-0-0      1       
 8  0-0-0-0!10!9     0       
 9  0-0-0-0-0-0      1       
 10 0-0-0-0-0-0      1       
```

Номер отгороженный !! указывает на добавление нового символа (новый путь)

Номер отгороженный >< указывает на то что мы идем по номерам уже введенной строки

Оказываясь постоянно на одних и тех же символах мы прийдем к тому, что новые символы вводить не надо и получим дубликат.

# Идея для вывода количества дубликатов и уникальных строк!

При создании общей карты GO и массива term создается еще один массив индексов.

В этот массив text заносятся индексы начала строк в буфере строк. Строки в буфере идут одна за другой с нуль терминатором.

Таким образом получая данный индекс всегда можно вывести строку стандартным методом.

Если индекс term не соответствует концу строки. То там ничего не ставим.

Если строка повторяется то оставляем предыдущий указатель который был в text.

Таким образом проводя потом парсинг по term можно найти все уникальные и все дублирующиеся строки и вывести их. 

Пример add 'bace' снова

5) bace
```
        GO           term    text
    a-b-c-d-e-f              
    0-1-2-3-4-5              
 0  1>5<0-0-0-0      0       0
 1  0-2-0-0-0-0      0       0
 2  0-0-3-4-0-0      0       0
 3  0-0-0-0-0-0      1       1
 4  0-0-0-0-0-0      1       5
 5 >6<0-0-0-0-0      0       0
 6  0-0>8<7-0-0      0       0
 7  0-0-0-0-0-0      1       11
 8  0-0-0-0!10!9     0       0
 9  0-0-0-0-0-0      1       16
 10 0-0-0-0-0-0      2       22
```

```
buffer
1    5    11  16     22  
|    |    |   |      |     
abc\0abd\0bad\0bacf\0bace\0
```